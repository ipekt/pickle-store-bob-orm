// Code generated by BobGen psql v0.28.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"hash/maphash"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
)

var TableNames = struct {
	Customers string
	Orders    string
	Products  string
}{
	Customers: "customers",
	Orders:    "orders",
	Products:  "products",
}

var ColumnNames = struct {
	Customers customerColumnNames
	Orders    orderColumnNames
	Products  productColumnNames
}{
	Customers: customerColumnNames{
		CustomerID: "customer_id",
		FirstName:  "first_name",
		LastName:   "last_name",
		Email:      "email",
	},
	Orders: orderColumnNames{
		OrderID:    "order_id",
		CustomerID: "customer_id",
		ProductID:  "product_id",
		Quantity:   "quantity",
		OrderDate:  "order_date",
	},
	Products: productColumnNames{
		ProductID:     "product_id",
		Name:          "name",
		Description:   "description",
		Price:         "price",
		StockQuantity: "stock_quantity",
	},
}

var (
	SelectWhere = Where[*dialect.SelectQuery]()
	InsertWhere = Where[*dialect.InsertQuery]()
	UpdateWhere = Where[*dialect.UpdateQuery]()
	DeleteWhere = Where[*dialect.DeleteQuery]()
)

func Where[Q psql.Filterable]() struct {
	Customers customerWhere[Q]
	Orders    orderWhere[Q]
	Products  productWhere[Q]
} {
	return struct {
		Customers customerWhere[Q]
		Orders    orderWhere[Q]
		Products  productWhere[Q]
	}{
		Customers: buildCustomerWhere[Q](CustomerColumns),
		Orders:    buildOrderWhere[Q](OrderColumns),
		Products:  buildProductWhere[Q](ProductColumns),
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]()
	UpdateJoins = getJoins[*dialect.UpdateQuery]()
	DeleteJoins = getJoins[*dialect.DeleteQuery]()
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	Customers joinSet[customerJoins[Q]]
	Orders    joinSet[orderJoins[Q]]
	Products  joinSet[productJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		Customers: buildJoinSet[customerJoins[Q]](CustomerColumns, buildCustomerJoins),
		Orders:    buildJoinSet[orderJoins[Q]](OrderColumns, buildOrderJoins),
		Products:  buildJoinSet[productJoins[Q]](ProductColumns, buildProductJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}
